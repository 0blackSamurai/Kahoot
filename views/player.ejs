<%- include('./partials/header') %>
<link rel="stylesheet" href="/css/kahoot-dark.css">

<div class="player-container">
    <div class="player-header">
        <h1><span id="quizTitle">Loading quiz...</span></h1>
        <div class="game-info">
            <span class="player-name"><%= playerName %></span>
            <span class="game-code"><%= gameCode %></span>
        </div>
        <div class="waiting-message" id="waitingMessage">Waiting for the host to start the game...</div>
        <div class="question-info" id="questionInfo" style="display:none;">
            <div class="question-counter">Question <span id="currentQuestion">1</span>/<span id="totalQuestions">?</span></div>
            <div class="score-display">Score: <span id="playerScore">0</span></div>
        </div>
        <div class="timer-container" id="timerContainer" style="display:none;">
            <div class="timer-bar" id="timerBar"></div>
            <div class="timer-text" id="timerText">30</div>
        </div>
    </div>
    
    <div class="waiting-area" id="waitingArea">
        <div class="spinner"></div>
        <p>Ready to play!</p>
    </div>
    
    <div class="question-area" id="questionArea" style="display:none;">
        <div id="questionText" class="question-text">Loading question...</div>
        
        <!-- Multiple choice question type -->
        <div id="multipleChoiceArea" class="options-grid question-type-container">
            <button class="option-button red" id="option0" data-index="0">
                <div class="option-symbol">▲</div>
                <div class="option-text">Option 1</div>
            </button>
            <button class="option-button blue" id="option1" data-index="1">
                <div class="option-symbol">◆</div>
                <div class="option-text">Option 2</div>
            </button>
            <button class="option-button yellow" id="option2" data-index="2">
                <div class="option-symbol">●</div>
                <div class="option-text">Option 3</div>
            </button>
            <button class="option-button green" id="option3" data-index="3">
                <div class="option-symbol">■</div>
                <div class="option-text">Option 4</div>
            </button>
        </div>
        
        <!-- Text answer question type -->
        <div id="textAnswerArea" class="text-answer-area question-type-container" style="display:none">
            <div class="text-input-container">
                <input type="text" id="textAnswerInput" class="text-answer-input" placeholder="Skriv inn svaret her...">
                <button id="submitTextAnswer" class="btn-submit">Send svar</button>
            </div>
        </div>

        <!-- True/False question type -->
        <div id="trueFalseArea" class="true-false-area question-type-container" style="display:none">
            <div class="true-false-options">
                <button class="true-button" id="trueButton">SANT</button>
                <button class="false-button" id="falseButton">USANT</button>
            </div>
        </div>
    </div>
    
    <div class="answer-status" id="answerStatus" style="display:none;">
        <div class="answer-icon">
            <i id="answerIcon" class="fas fa-check"></i>
        </div>
        <div id="answerMessage" class="answer-message">Answer received!</div>
        <div id="answerPoints" class="answer-points">+0 points</div>
        <div class="waiting-next">Waiting for next question...</div>
    </div>
    
    <div class="results-area" id="resultsArea" style="display:none;">
        <h2>Game Over!</h2>
        <div class="final-rank">
            <div class="rank-title">Your Rank</div>
            <div class="rank-display">#<span id="playerRank">?</span></div>
            <div class="final-score">Score: <span id="finalScore">0</span></div>
        </div>
        <div class="top-players" id="topPlayers">
            <!-- Top players will be added here -->
        </div>
        <div class="result-actions">
            <a href="/quiz/join" class="btn-join-new">Play Another Quiz</a>
            <a href="/" class="btn-back-home">Back to Home</a>
        </div>
    </div>
</div>

<style>
    body {
        background-color: var(--dark-bg);
        margin: 0;
        padding: 0;
        height: 100vh;
        overflow: hidden;
    }
    .player-container {
        max-width: 900px;
        margin: 0 auto;
        padding: 20px;
        height: calc(100vh - 100px);
        display: flex;
        flex-direction: column;
    }
    .player-header {
        background-color: rgba(45, 45, 45, 0.85);
        border-radius: 12px;
        padding: 15px;
        margin-bottom: 20px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    .player-header h1 {
        font-size: 1.8rem;
        margin: 0 0 10px 0;
        color: white;
        text-align: center;
    }
    .game-info {
        display: flex;
        justify-content: space-between;
        margin: 10px 0;
        font-size: 1.1rem;
        color: #ddd;
    }
    .waiting-message {
        text-align: center;
        color: var(--kahoot-light-purple);
        font-size: 1.1rem;
        margin-top: 10px;
        animation: pulse 1.5s infinite;
    }
    .timer-container {
        width: 100%;
        height: 12px;
        background-color: #444;
        border-radius: 6px;
        margin-top: 10px;
        position: relative;
    }
    .timer-bar {
        height: 100%;
        width: 100%;
        background: linear-gradient(90deg, var(--kahoot-purple) 0%, var(--kahoot-blue) 100%);
        border-radius: 6px;
        transition: width 1s linear;
    }
    .timer-text {
        position: absolute;
        right: 10px;
        top: -25px;
        color: #fff;
        font-weight: bold;
    }
    .waiting-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }
    .spinner {
        width: 50px;
        height: 50px;
        border: 5px solid rgba(142, 82, 245, 0.3);
        border-top-color: var(--kahoot-light-purple);
        border-radius: 50%;
        animation: spin 1s infinite linear;
        margin-bottom: 20px;
    }
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    .question-area {
        flex: 1;
        display: flex;
        flex-direction: column;
    }
    .question-text {
        background-color: var(--dark-card-bg);
        padding: 20px;
        border-radius: 12px;
        font-size: 1.5rem;
        color: white;
        margin-bottom: 20px;
        text-align: center;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    .options-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
        flex: 1;
    }
    .option-button {
        border: none;
        border-radius: 12px;
        padding: 25px 15px;
        font-size: 1.2rem;
        color: white;
        font-weight: bold;
        cursor: pointer;
        position: relative;
        overflow: hidden;
        display: flex;
        align-items: center;
        transition: transform 0.2s, box-shadow 0.2s;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        min-height: 100px;
    }
    .option-button:hover {
        transform: translateY(-5px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
    }
    .option-button:active {
        transform: translateY(0);
    }
    .option-button.red { background-color: var(--kahoot-red); }
    .option-button.blue { background-color: var(--kahoot-blue); }
    .option-button.yellow { background-color: var(--kahoot-yellow); }
    .option-button.green { background-color: var(--kahoot-green); }
    .option-symbol {
        font-size: 24px;
        margin-right: 15px;
        background: white;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 5px;
        color: #333;
    }
    .option-button .option-text {
        flex: 1;
        text-align: left;
    }
    .option-button.selected {
        border: 4px solid white;
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        transform: scale(0.98);
    }
    .option-button.disabled {
        opacity: 0.7;
        cursor: not-allowed;
        transform: none;
    }
    .answer-status {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background-color: rgba(30, 30, 30, 0.95);
        z-index: 100;
    }
    .answer-icon {
        font-size: 72px;
        margin-bottom: 20px;
        animation: bounceIn 0.5s;
    }
    .answer-icon .fa-check { color: var(--kahoot-green); }
    .answer-icon .fa-times { color: var(--kahoot-red); }
    .answer-message {
        font-size: 2rem;
        font-weight: bold;
        color: white;
        margin-bottom: 10px;
    }
    .answer-points {
        font-size: 1.5rem;
        color: var(--kahoot-light-purple);
        margin-bottom: 30px;
    }
    .waiting-next {
        color: var(--dark-text-secondary);
        animation: pulse 1.5s infinite;
    }
    .results-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
    }
    .results-area h2 {
        color: white;
        font-size: 2.5rem;
        margin-bottom: 30px;
    }
    .final-rank {
        margin-bottom: 30px;
    }
    .rank-title {
        color: var(--dark-text-secondary);
        font-size: 1.2rem;
        margin-bottom: 5px;
    }
    .rank-display {
        font-size: 3.5rem;
        font-weight: bold;
        color: var(--kahoot-light-purple);
        margin-bottom: 10px;
    }
    .final-score {
        font-size: 1.5rem;
        color: white;
    }
    .top-players {
        background-color: var(--dark-card-bg);
        border-radius: 10px;
        padding: 15px;
        width: 100%;
        max-width: 400px;
        margin-bottom: 30px;
    }
    .player-row {
        display: flex;
        justify-content: space-between;
        padding: 10px 15px;
        border-bottom: 1px solid var(--dark-border);
    }
    .player-row:last-child {
        border-bottom: none;
    }
    .player-row.highlight {
        background-color: rgba(142, 82, 245, 0.2);
        border-radius: 5px;
    }
    .player-rank {
        width: 30px;
        font-weight: bold;
        color: var(--kahoot-light-purple);
    }
    .player-name {
        flex: 1;
        text-align: left;
        margin: 0 10px;
        color: white;
    }
    .player-score {
        color: var(--dark-text-secondary);
    }
    .result-actions {
        display: flex;
        gap: 15px;
    }
    .btn-join-new, .btn-back-home {
        background-color: var(--kahoot-green);
        color: white;
        border: none;
        padding: 12px 25px;
        font-size: 1.1rem;
        border-radius: 8px;
        cursor: pointer;
        text-decoration: none;
        transition: all 0.2s;
    }
    .btn-back-home {
        background-color: var(--dark-input-bg);
    }
    .btn-join-new:hover, .btn-back-home:hover {
        transform: translateY(-3px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    @keyframes pulse {
        0% { opacity: 0.7; }
        50% { opacity: 1; }
        100% { opacity: 0.7; }
    }
    @keyframes bounceIn {
        0% { transform: scale(0); }
        50% { transform: scale(1.2); }
        100% { transform: scale(1); }
    }
    /* Responsive adjustments for mobile */
    @media (max-width: 768px) {
        .options-grid {
            grid-template-columns: 1fr;
            gap: 10px;
        }
        .option-button {
            padding: 15px;
            font-size: 1rem;
            min-height: 70px;
        }
        .question-text {
            font-size: 1.2rem;
            padding: 15px;
        }
    }
    /* Add score update animation */
    @keyframes scoreUpdate {
        0% { transform: scale(1); }
        50% { transform: scale(1.5); color: var(--kahoot-green); }
        100% { transform: scale(1); }
    }
    .score-update {
        animation: scoreUpdate 0.8s ease-in-out;
    }
    /* Add host disconnect message style */
    .host-disconnect-message {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(30, 30, 30, 0.9);
        color: white;
        padding: 10px 20px;
        border-radius: 8px;
        text-align: center;
        z-index: 1000;
        display: flex;
        align-items: center;
        gap: 10px;
        animation: slideDown 0.3s;
    }
    .host-disconnect-message i {
        color: var(--kahoot-yellow);
    }
    @keyframes slideDown {
        from { transform: translate(-50%, -50px); opacity: 0; }
        to { transform: translate(-50%, 0); opacity: 1; }
    }
    /* Improved text answer styles */
    .text-answer-area {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        width: 100%;
        padding: 20px 0;
        background-color: transparent;
    }
    .text-input-container {
        width: 100%;
        max-width: 500px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 15px;
    }
    .text-answer-input {
        width: 100%;
        padding: 20px;
        font-size: 1.8rem;
        border: 3px solid var(--kahoot-light-purple);
        border-radius: 12px;
        color: #333;
        background-color: white;
        text-align: center;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
        -webkit-appearance: none; /* Fix for iOS */
    }
    .text-answer-input:focus {
        outline: none;
        border-color: var(--kahoot-purple);
        box-shadow: 0 0 0 4px rgba(142, 82, 245, 0.3);
    }
    .btn-submit {
        width: 100%;
        padding: 18px;
        font-size: 1.4rem;
        background-color: var(--kahoot-green);
        color: white;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.2s ease;
    }
    .btn-submit:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
        background-color: #26A65B;
    }
    .btn-submit:active {
        transform: translateY(1px);
    }
    .btn-submit.disabled {
        background-color: #888;
        transform: none;
        cursor: not-allowed;
    }
    /* Animation to indicate wrong/missing input */
    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
        20%, 40%, 60%, 80% { transform: translateX(5px); }
    }
    .shake {
        animation: shake 0.5s;
    }
    /* Improved True/False styling to match play view */
    .true-false-area {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        width: 100%;
        padding: 20px 0;
    }
    
    .true-false-options {
        display: flex;
        justify-content: center;
        gap: 30px;
        width: 100%;
        max-width: 600px;
    }
    
    .true-button, .false-button {
        flex: 1;
        min-height: 180px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        border: none;
        border-radius: 15px;
        padding: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 8px 0 rgba(0,0,0,0.2);
        position: relative;
        overflow: hidden;
        font-size: 2rem;
        font-weight: bold;
    }
    
    .true-button {
        background-color: var(--kahoot-green);
        color: white;
    }
    
    .false-button {
        background-color: var(--kahoot-red);
        color: white;
    }
    
    .true-button:hover, .false-button:hover {
        transform: translateY(-5px);
        box-shadow: 0 12px 0 rgba(0,0,0,0.2);
    }
    
    .true-button:active, .false-button:active {
        transform: translateY(3px);
        box-shadow: 0 5px 0 rgba(0,0,0,0.2);
    }
    
    .true-button.selected, .false-button.selected {
        transform: scale(0.95);
        box-shadow: 0 3px 0 rgba(0,0,0,0.2);
        border: 3px solid white;
    }
    
    .true-button.correct, .false-button.correct {
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
        border: 3px solid white;
        animation: pulse-border 1.5s infinite;
    }
    
    @keyframes pulse-border {
        0% { box-shadow: 0 0 0 0 rgba(255,255,255,0.8); }
        70% { box-shadow: 0 0 0 15px rgba(255,255,255,0); }
        100% { box-shadow: 0 0 0 0 rgba(255,255,255,0); }
    }
    
    /* Ripple effect for buttons */
    .ripple {
        position: absolute;
        background: rgba(255, 255, 255, 0.4);
        border-radius: 50%;
        transform: scale(0);
        animation: ripple 0.6s linear;
        pointer-events: none;
    }
    
    @keyframes ripple {
        to { transform: scale(2.5); opacity: 0; }
    }
    
    /* Responsive adjustments for true/false */
    @media (max-width: 768px) {
        .true-false-options {
            flex-direction: column;
            gap: 15px;
        }
        
        .true-button, .false-button {
            min-height: 120px;
            width: 100%;
        }
    }
</style>

<script src="/socket.io/socket.io.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Connect to Socket.io
        const socket = io();
        
        // Get game data from server
        const gameCode = '<%= gameCode %>';
        const playerName = '<%= playerName %>';
        const playerId = '<%= locals.userId || "" %>';
        
        // UI Elements
        const waitingArea = document.getElementById('waitingArea');
        const questionArea = document.getElementById('questionArea');
        const answerStatus = document.getElementById('answerStatus');
        const resultsArea = document.getElementById('resultsArea');
        const waitingMessage = document.getElementById('waitingMessage');
        const questionInfo = document.getElementById('questionInfo');
        const timerContainer = document.getElementById('timerContainer');
        const timerBar = document.getElementById('timerBar');
        const timerText = document.getElementById('timerText');
        const questionText = document.getElementById('questionText');
        const currentQuestion = document.getElementById('currentQuestion');
        const totalQuestions = document.getElementById('totalQuestions');
        const playerScore = document.getElementById('playerScore');
        const quizTitle = document.getElementById('quizTitle');
        
        // Answer feedback elements
        const answerIcon = document.getElementById('answerIcon');
        const answerMessage = document.getElementById('answerMessage');
        const answerPoints = document.getElementById('answerPoints');
        
        // Results elements
        const playerRank = document.getElementById('playerRank');
        const finalScore = document.getElementById('finalScore');
        const topPlayers = document.getElementById('topPlayers');
        
        // Option buttons
        const optionButtons = [
            document.getElementById('option0'),
            document.getElementById('option1'),
            document.getElementById('option2'),
            document.getElementById('option3')
        ];

        // Additional UI Elements for different question types
        const multipleChoiceArea = document.getElementById('multipleChoiceArea');
        const textAnswerArea = document.getElementById('textAnswerArea');
        const textAnswerInput = document.getElementById('textAnswerInput');
        const submitTextAnswer = document.getElementById('submitTextAnswer');
        const trueFalseArea = document.getElementById('trueFalseArea');
        const trueButton = document.getElementById('trueButton');
        const falseButton = document.getElementById('falseButton');
        const nextQuestionBtn = null;
        
        // Game state
        let currentQuestionIndex = 0;
        let score = 0;
        let timeLeft = 0;
        let timer = null;
        let questionData = null;
        let answered = false;
        let totalQuestionsCount = 0;
        let isGameActive = false;
        let lastQuestionIndex = -1;
        let isLastQuestion = false;
        
        // Debug function - add this to help troubleshoot
        function debugLog(message) {
            console.log(`[PLAYER DEBUG] ${message}`);
        }
        
        debugLog("Player view initialized");
        
        // Join the game
        socket.emit('join-game', {
            gameCode,
            playerName,
            playerId
        });
        
        // Listen for game events
        socket.on('join-success', (data) => {
            debugLog('Successfully joined game: ' + JSON.stringify(data));
            quizTitle.textContent = data.quizTitle || 'Quiz Game';
            
            // If game is already in progress, check the current question
            if (data.gameInProgress) {
                debugLog('Game already in progress, catching up...');
                isGameActive = true;
                currentQuestionIndex = data.currentQuestionIndex || 0;
                
                // Show a message that we're catching up
                waitingMessage.textContent = "Game in progress. Catching up...";
                
                // Request the current question data
                socket.emit('get-question', {
                    gameCode,
                    questionIndex: currentQuestionIndex
                });
            }
        });
        
        socket.on('join-failed', (data) => {
            debugLog('Failed to join game: ' + data.message);
            alert('Failed to join game: ' + data.message);
            window.location.href = '/quiz/join';
        });
        
        socket.on('game-started', () => {
            debugLog('Game started event received');
            isGameActive = true;
            waitingMessage.textContent = 'Get ready! Game starting...';
            
            // Reset game state when starting fresh
            currentQuestionIndex = 0;
            score = 0;
            playerScore.textContent = '0';
            
            // The host will send a question-started event next, so we don't need to do anything else here
        });
        
        socket.on('question-started', (data) => {
            debugLog('Question started event received: ' + JSON.stringify(data));
            currentQuestionIndex = data.questionIndex;
            
            // Check if this is a new question or if we're catching up
            if (currentQuestionIndex > lastQuestionIndex) {
                lastQuestionIndex = currentQuestionIndex;
            }
            
            // Reset for new question
            resetQuestion();
            
            // Request question data from server
            socket.emit('get-question', {
                gameCode,
                questionIndex: currentQuestionIndex
            });
        });
        
        socket.on('question-data', (data) => {
            debugLog('Received question data: ' + JSON.stringify(data));
            questionData = data;
            totalQuestionsCount = data.totalQuestions;
            
            // Determine if this is the last question
            isLastQuestion = (currentQuestionIndex === totalQuestionsCount - 1);
            debugLog(`Question ${currentQuestionIndex + 1}/${totalQuestionsCount} - Is last: ${isLastQuestion}`);
            
            // Update UI with question data
            loadQuestion(data);
        });
        
        socket.on('question-ended', () => {
            debugLog('Question ended event received');
            clearInterval(timer);
            
            // If not answered, show timeout
            if (!answered) {
                showAnswerFeedback(false, 0, 'Time\'s Up!');
            }
            
            // Update waiting message
            const waitingNext = document.querySelector('.waiting-next');
            if (waitingNext) {
                if (isLastQuestion) {
                    waitingNext.textContent = 'Game complete! Waiting for results...';
                } else {
                    waitingNext.textContent = 'Waiting for host to continue...';
                }
            }
        });
        
        socket.on('answer-result', (data) => {
            debugLog('Answer result received: ' + JSON.stringify(data));
            
            // Update feedback with actual result
            showAnswerFeedback(data.isCorrect, data.points, data.isCorrect ? 'Correct!' : 'Incorrect!');
            
            // Update score if correct
            if (data.isCorrect) {
                score += data.points;
                playerScore.textContent = score;
                
                // Add success animation to the score
                playerScore.classList.add('score-update');
                setTimeout(() => {
                    playerScore.classList.remove('score-update');
                }, 1000);
            }
        });
        
        socket.on('game-over', (data) => {
            debugLog('Game over event received: ' + JSON.stringify(data));
            
            // Process player data if not already ranked
            if (data.players && !data.players[0].hasOwnProperty('rank')) {
                // Sort players by score (highest first)
                data.players.sort((a, b) => b.score - a.score);
                
                // Add rankings
                data.players.forEach((player, index) => {
                    player.rank = index + 1;
                });
            }
            
            // Show final results
            showResults(data);
            isGameActive = false;
            
            // Clear any existing buttons in the answer status area
            const answerStatusButtons = document.querySelectorAll('#answerStatus button');
            answerStatusButtons.forEach(button => button.style.display = 'none');
            
            // Ensure results are shown even if answer status is displayed
            answerStatus.style.display = 'none';
        });
        
        // Function to reset question state
        function resetQuestion() {
            debugLog('Resetting question state');
            answered = false;
            clearInterval(timer);
            
            // Reset UI
            waitingArea.style.display = 'none';
            questionArea.style.display = 'block';
            answerStatus.style.display = 'none';
            questionInfo.style.display = 'block';
            timerContainer.style.display = 'block';
            
            // Hide all question type areas first
            multipleChoiceArea.style.display = 'none';
            textAnswerArea.style.display = 'none';
            trueFalseArea.style.display = 'none';
            
            // Reset multiple choice buttons
            optionButtons.forEach(button => {
                button.classList.remove('selected', 'disabled');
                button.disabled = false;
            });
            
            // Reset text answer
            textAnswerInput.value = '';
            textAnswerInput.disabled = false;
            submitTextAnswer.disabled = false;
            
            // Reset true/false buttons
            trueButton.classList.remove('selected', 'disabled');
            falseButton.classList.remove('selected', 'disabled');
            trueButton.disabled = false;
            falseButton.disabled = false;
        }
        
        // Function to load question data
        function loadQuestion(data) {
            debugLog('Loading question data');
            questionText.textContent = data.questionText;
            currentQuestion.textContent = currentQuestionIndex + 1;
            totalQuestions.textContent = totalQuestionsCount;
            
            // Determine question type and show appropriate interface
            const questionType = data.questionType || 'multiple-choice';
            
            // Reset UI for all question types first
            multipleChoiceArea.style.display = 'none';
            textAnswerArea.style.display = 'none';
            trueFalseArea.style.display = 'none';
            
            debugLog('Question type detected: ' + questionType);
            
            switch (questionType) {
                case 'text-answer':
                    debugLog('Showing text answer area');
                    
                    // Show text answer interface
                    textAnswerArea.style.display = 'block';
                    
                    // Set custom placeholder if provided
                    if (data.textAnswer && data.textAnswer.placeholder) {
                        textAnswerInput.placeholder = data.textAnswer.placeholder;
                    } else {
                        textAnswerInput.placeholder = "Skriv inn svaret her...";
                    }
                    
                    // Reset the input field
                    textAnswerInput.value = '';
                    textAnswerInput.disabled = false;
                    submitTextAnswer.disabled = false;
                    submitTextAnswer.classList.remove('disabled');
                    textAnswerInput.style.borderColor = "var(--kahoot-light-purple)";
                    textAnswerInput.style.backgroundColor = "white";
                    
                    // Focus on the input field
                    setTimeout(() => {
                        textAnswerInput.focus();
                        debugLog('Input field focused');
                    }, 300);
                    break;
                    
                case 'true-false':
                    debugLog('Showing true/false area');
                    trueFalseArea.style.display = 'block';
                    
                    // Reset true/false buttons
                    trueButton.classList.remove('selected');
                    falseButton.classList.remove('selected');
                    trueButton.disabled = false;
                    falseButton.disabled = false;
                    break;
                    
                case 'multiple-choice':
                default:
                    debugLog('Showing multiple choice area');
                    // Show multiple choice interface and set options
                    multipleChoiceArea.style.display = 'grid';
                    
                    // Set options text
                    for (let i = 0; i < data.options.length && i < optionButtons.length; i++) {
                        optionButtons[i].querySelector('.option-text').textContent = data.options[i].text;
                        optionButtons[i].style.display = 'flex';
                        optionButtons[i].classList.remove('selected', 'disabled');
                        optionButtons[i].disabled = false;
                    }
                    
                    // Hide unused options
                    for (let i = data.options.length; i < optionButtons.length; i++) {
                        optionButtons[i].style.display = 'none';
                    }
                    break;
            }
            
            // Start timer
            timeLeft = data.timeLimit || 30;
            startTimer();
        }
        
        // Function to start timer countdown
        function startTimer() {
            debugLog('Starting timer with ' + timeLeft + ' seconds');
            timerText.textContent = timeLeft;
            timerBar.style.width = '100%';
            
            timer = setInterval(() => {
                timeLeft--;
                timerText.textContent = timeLeft;
                
                // Update timer bar
                const percentage = (timeLeft / (questionData.timeLimit || 30)) * 100;
                timerBar.style.width = `${percentage}%`;
                
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    if (!answered) {
                        // Time's up without answering
                        disableOptions();
                        
                        // Tell server we didn't answer
                        socket.emit('submit-answer', {
                            gameCode,
                            questionIndex: currentQuestionIndex,
                            answerIndex: -1,
                            playerId: playerId || socket.id
                        });
                        
                        showAnswerFeedback(false, 0, 'Time\'s Up!');
                    }
                }
            }, 1000);
        }
        
        // Function to handle answer selection
        function selectAnswer(index) {
            debugLog('Selected answer ' + index);
            if (answered) return;
            answered = true;
            clearInterval(timer);
            
            // Mark selected option
            optionButtons.forEach(button => {
                button.classList.add('disabled');
                button.disabled = true;
            });
            optionButtons[index].classList.add('selected');
            
            // Send answer to server
            socket.emit('submit-answer', {
                gameCode,
                questionIndex: currentQuestionIndex,
                answerIndex: index,
                playerId: playerId || socket.id,
                timeLeft: timeLeft // Send remaining time for score calculation
            });
            
            // Show temporary answer received message
            showAnswerFeedback(null, null, 'Answer received!');
        }
        
        // Improved text answer submission handler
        function submitTextAnswerHandler() {
            if (answered) return;
            
            debugLog('Submit text answer clicked');
            
            // Get the answer text and trim whitespace
            const answer = textAnswerInput.value.trim();
            
            // Don't submit if answer is empty
            if (answer === '') {
                textAnswerInput.classList.add('shake');
                setTimeout(() => textAnswerInput.classList.remove('shake'), 500);
                return;
            }
            
            // Mark as answered to prevent multiple submissions
            answered = true;
            clearInterval(timer);
            
            // Disable input and button
            textAnswerInput.disabled = true;
            submitTextAnswer.disabled = true;
            submitTextAnswer.classList.add('disabled');
            
            // Visual feedback for the input
            textAnswerInput.style.borderColor = "var(--kahoot-green)";
            textAnswerInput.style.backgroundColor = "rgba(38, 166, 91, 0.05)";
            
            debugLog('Sending text answer: ' + answer);
            
            // Send answer to server
            socket.emit('submit-answer', {
                gameCode,
                questionIndex: currentQuestionIndex,
                textAnswer: answer,
                playerId: playerId || socket.id,
                timeLeft: timeLeft
            });
            
            // Show temporary answer received message
            showAnswerFeedback(null, null, 'Svar sendt!');
        }
        
        // Add better event handling for text answers
        submitTextAnswer.addEventListener('click', submitTextAnswerHandler);
        
        textAnswerInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                submitTextAnswerHandler();
            }
        });
        
        trueButton.addEventListener('click', function() {
            submitTrueFalseAnswer(true);
        });
        
        falseButton.addEventListener('click', function() {
            submitTrueFalseAnswer(false);
        });
        
        function submitTrueFalseAnswer(answer) {
            if (answered) return;
            answered = true;
            clearInterval(timer);
            
            // Add ripple effect
            const button = answer ? trueButton : falseButton;
            addRippleEffect(button);
            
            // Update UI
            if (answer) {
                trueButton.classList.add('selected');
            } else {
                falseButton.classList.add('selected');
            }
            
            // Disable buttons
            trueButton.disabled = true;
            falseButton.disabled = true;
            
            // Send answer to server
            socket.emit('submit-answer', {
                gameCode,
                questionIndex: currentQuestionIndex,
                answer: answer,
                playerId: playerId || socket.id,
                timeLeft: timeLeft
            });
            
            // Show temporary answer received message
            showAnswerFeedback(null, null, 'Answer received!');
        }
        
        // Add ripple effect function
        function addRippleEffect(button) {
            const ripple = document.createElement('span');
            ripple.className = 'ripple';
            button.appendChild(ripple);
            
            const buttonRect = button.getBoundingClientRect();
            const diameter = Math.max(buttonRect.width, buttonRect.height);
            
            ripple.style.width = ripple.style.height = `${diameter}px`;
            ripple.style.left = '50%';
            ripple.style.top = '50%';
            ripple.style.transform = 'translate(-50%, -50%)';
            
            setTimeout(() => ripple.remove(), 600);
        }
        
        // Handle reveal-answer event from server
        socket.on('reveal-answer', (data) => {
            if (data.questionType === 'true-false') {
                // Highlight correct answer
                if (data.correctAnswer === true) {
                    trueButton.classList.add('correct');
                } else {
                    falseButton.classList.add('correct');
                }
            }
        });
        
        // Update the function to disable options based on question type
        function disableOptions() {
            // Get current question type from data
            const questionType = questionData ? (questionData.questionType || 'multiple-choice') : 'multiple-choice';
            
            switch (questionType) {
                case 'text-answer':
                    textAnswerInput.disabled = true;
                    submitTextAnswer.disabled = true;
                    break;
                    
                case 'true-false':
                    trueButton.disabled = true;
                    falseButton.disabled = true;
                    break;
                    
                case 'multiple-choice':
                default:
                    optionButtons.forEach(button => {
                        button.classList.add('disabled');
                        button.disabled = true;
                    });
                    break;
            }
        }
        
        // Function to show answer feedback
        function showAnswerFeedback(isCorrect, points, message) {
            debugLog('Showing answer feedback: ' + message);
            questionArea.style.display = 'none';
            answerStatus.style.display = 'flex';
            
            // If we don't know if correct yet, show neutral message
            if (isCorrect === null) {
                answerIcon.className = 'fas fa-check-circle';
                answerIcon.style.color = 'var(--kahoot-light-purple)';
                answerMessage.textContent = message || 'Answer received!';
                answerPoints.textContent = '';
            } else if (isCorrect) {
                answerIcon.className = 'fas fa-check';
                answerIcon.style.color = 'var(--kahoot-green)';
                answerMessage.textContent = message || 'Correct!';
                answerPoints.textContent = `+${points} points`;
                
                // Update score
                score += points;
                playerScore.textContent = score;
                
                // Add success animation to the score
                playerScore.classList.add('score-update');
                setTimeout(() => {
                    playerScore.classList.remove('score-update');
                }, 1000);
                
                // Report updated score to host
                socket.emit('update-player-score', {
                    gameCode,
                    playerId: playerId || socket.id,
                    score: score,
                    questionIndex: currentQuestionIndex
                });
            } else {
                answerIcon.className = 'fas fa-times';
                answerIcon.style.color = 'var(--kahoot-red)';
                answerMessage.textContent = message || 'Incorrect!';
                answerPoints.textContent = '+0 points';
            }
        }
        
        // Function to show final results
        function showResults(data) {
            debugLog('Showing final results');
            // Update UI elements
            waitingArea.style.display = 'none';
            questionArea.style.display = 'none';
            answerStatus.style.display = 'none';
            resultsArea.style.display = 'flex';
            
            // Set player's results
            let playerData = null;
            if (data.players) {
                playerData = data.players.find(p => 
                    p.id === playerId || 
                    p.id === socket.id ||
                    p.socketId === socket.id ||
                    p.name === playerName
                );
            }
            
            if (playerData) {
                playerRank.textContent = playerData.rank || "-";
                finalScore.textContent = playerData.score || score;
                debugLog(`Found player data: rank=${playerData.rank}, score=${playerData.score}`);
            } else {
                playerRank.textContent = "-";
                finalScore.textContent = score;
                debugLog('Player data not found in results, using local score');
            }
            
            // Display top players
            topPlayers.innerHTML = '';
            
            if (data.players && data.players.length > 0) {
                const top5Players = data.players.slice(0, 5);
                debugLog(`Displaying top ${top5Players.length} players`);
                
                top5Players.forEach((player, index) => {
                    const isCurrentPlayer = 
                        player.id === playerId || 
                        player.id === socket.id ||
                        player.socketId === socket.id ||
                        player.name === playerName;
                        
                    const playerRow = document.createElement('div');
                    playerRow.className = `player-row ${isCurrentPlayer ? 'highlight' : ''}`;
                    
                    const rank = player.rank || index + 1;
                    playerRow.innerHTML = `
                        <div class="player-rank">#${rank}</div>
                        <div class="player-name">${player.name}${isCurrentPlayer ? ' (You)' : ''}</div>
                        <div class="player-score">${player.score || 0}</div>
                    `;
                    
                    topPlayers.appendChild(playerRow);
                });
            } else {
                // Fallback if no player data is provided
                topPlayers.innerHTML = '<div class="player-row"><div class="player-name">No player data available</div></div>';
                debugLog('No player data available for results display');
            }
        }
        
        // Add event listeners to option buttons
        optionButtons.forEach(button => {
            button.addEventListener('click', function() {
                const index = parseInt(this.dataset.index);
                selectAnswer(index);
            });
        });
        
        // Add reconnection logic for players who refresh or reconnect
        socket.on('reconnect', () => {
            debugLog('Socket reconnected - rejoining game');
            socket.emit('join-game', {
                gameCode,
                playerName,
                playerId: playerId || socket.id
            });
        });
        
        // Get game state on connect if game is active
        socket.on('connect', () => {
            debugLog('Socket connected');
            if (isGameActive) {
                socket.emit('get-game-state', { gameCode });
            }
        });

        // Enhance reconnection logic
        socket.on('connect', () => {
            console.log('Socket connected with ID:', socket.id);
            
            // Store connection info in localStorage to help with reconnection
            localStorage.setItem('gameCode', gameCode);
            localStorage.setItem('playerName', playerName);
            
            // If we were previously connected and playing
            if (isGameActive) {
                console.log('Reconnecting to game...');
                
                // Join the game again
                socket.emit('join-game', {
                    gameCode,
                    playerName,
                    playerId: playerId || localStorage.getItem('playerId') || socket.id
                });
                
                // Get current game state
                socket.emit('get-game-state', { gameCode });
            }
        });

        // Handle disconnection
        socket.on('disconnect', () => {
            console.log('Disconnected from server. Attempting to reconnect...');
            // The socket.io client will automatically try to reconnect
        });

        // Detect when reconnection fails
        socket.io.on('reconnect_failed', () => {
            alert('Failed to reconnect to the game server. Please refresh the page.');
        });

        // Track successful reconnection attempts
        socket.io.on('reconnect', (attemptNumber) => {
            console.log(`Reconnected to server after ${attemptNumber} attempts`);
        });

        // Handle host disconnection
        socket.on('host-disconnected', () => {
            debugLog('Host disconnected');
            // Show a message but keep the current view
            // This allows the game to continue if host reconnects
            const hostDisconnectMsg = document.createElement('div');
            hostDisconnectMsg.className = 'host-disconnect-message';
            hostDisconnectMsg.innerHTML = `
                <i class="fas fa-exclamation-triangle"></i>
                <p>Host disconnected. Waiting for reconnection...</p>
            `;
            document.body.appendChild(hostDisconnectMsg);
            
            setTimeout(() => {
                hostDisconnectMsg.remove();
            }, 5000);
        });

        // Handle request-results response
        socket.on('send-results', (data) => {
            debugLog('Received game results');
            showResults(data);
        });

        // Add new event for when host manually advances to next question
        socket.on('host-advance-question', () => {
            debugLog('Host advanced to next question');
            // Clear any pending UI elements from previous question
            const seeResultsButtons = document.querySelectorAll('.see-results-button');
            if (seeResultsButtons.length > 0) {
                seeResultsButtons.forEach(btn => btn.remove());
            }
            
            // Hide answer status to prepare for next question
            answerStatus.style.display = 'none';
            waitingArea.style.display = 'flex';
            waitingMessage.textContent = 'Host is loading the next question...';
        });
    });
</script>

<%- include('./partials/footer') %>
